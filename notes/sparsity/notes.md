## Sparsity

一个矩阵，或一个数组，当它内部大部分元素的值都是 0 的时候，在数值分析中会形容其稀疏。
与 Sparse 对应的，当一个矩阵或数组内大部分元素都是非零的时候，就被称为密集（Dense）。

```js
[
   [1, 2, 0, 0, 0, 0, 0, 0],
   [0, 0, 3, 4, 0, 0, 0, 0],
   [0, 0, 0, 0, 5, 6, 0, 0],
   [0, 0, 0, 0, 0, 0, 7, 8],
]
```

比如，对于一个 4 行 8 列，大小为 32 个元素的矩阵而言，当它有 8 个元素是不为 0 的，
而其他 24 个元素都是 0 的情况下，称这个矩阵的稀疏程度(Sparsity)为 75%，而密集程度为 25%。

```haskell
sparsity = zero_elem_count / matrix_size
   where zero_elem_count = length (filter (== 0) matrix)
         matrix_size     = length matrix
```


零值元素的比例要到多大才能被称为稀疏(Sparse)呢？这个没有严格定义，但一般标准上，非零元素的数量应该与矩阵
的行和列的数量大致相等。

稀疏这个概念主要用于网络工程和数理分析上。在脑海中想象一片森林，和一条条的树藤，在这个森林里，
每颗树之间可能会有树藤相连，也可能有完全孤立的，没有用树藤和别的树连接的树。
此时来计量树之间的连接性，把完全没有树藤的树记作 0，把只有一条树藤的树也记为 0。
此时想象在这篇森林中的某一块区域，有一排树是完全没有树藤的，
有一排树虽然有树藤，但是只有一条树藤将他们连成一条线，
只有寥寥几颗树会和更多树相连。
那么这一块领域内，就会称这些树是稀疏连接的，这一块领域则是一块稀疏领域。
与之对应的，在记录里，这一片领域对应的值将是大量的 0，只有少量的非零元素

与之相对的，再想象有一块区域，树和树之间不只是邻接着有树藤连接，而是彼此相连，
一棵树可能会和其他三四棵树相连。那么这一块区域就可以称作是一块密集领域。
与之对应的，这一块领域树的连接性对应的值都会是非零的值。

这类数值在计算中常常会出现，
理论上来说，压缩稀疏矩阵相对密集矩阵压缩起来会更加简单。
对于计算机而言，
为稀疏的矩阵设计特别的算法和数据结构可以帮助加速计算和提供高效的存储。
直接用普通的矩阵算法来操作稀疏矩阵是不太现实的。

在稀疏矩阵里，通常需要一个特殊的数据结构来存储和访问非零的元素。
具体的实现分成两种：

1. 支持高效修改的（这些操作通常用于构造稀疏矩阵）

* DOK (Dictionary of keys)

DOK 的实现方式是用字典作为数据结构，用行和列作为 key 来访问对应的矩阵值。
如果结果为空，那么该行列对应的值是零值。

   - Pros: 构造简单，可以增量更新
   - Cons: 无法存储非零值的次序，不便于顺序遍历操作。

* LIL (List of lists)

LIL 实现方式依旧是用二维数组，每一个列表元素也是一个数组，用来表示一整行。
与普通二维数组不同，在行内不直接存值，而是存元素的列的索引和对应的值。
比如当 (x1, y1) 的值为 v1 时，`matrix[x1] = [(y1, v1)]`。

```haskell
type Column = Int
type Value = Int

type Pair = (Column, Value)
type Row = [ Pair ]
type LIL = [ Row ]

to_lil [ [0, 8, 0], [9, 0, 3], [0, 0, 4] ]
-- > [
--     [(1, 8)],
--     [(0, 9), (2, 3)],
--     [(2, 4)],
--   ]
```

* COO (Coordinate list)

COO 则更进一步，拍扁了上述的数组，用三元元组来表达“行”，“列”，和“值”。比如当
(x1, y1) 的值为 v1 时，`matrix = [..., (x1, y1, v1), ...]`

2. 支持高效访问和数组操作的

* CSR (Compressed Sparse Row)
* CSC (Compressed Sparse Column)


