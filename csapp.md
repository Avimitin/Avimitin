## 2.1

1. Computer use 8 bit(aka 1byte) as the smallest unit of memory.
2. A machine level program view memory as a very large array of bytes, referred to as `Virtual Memory`
3. Each byte of that memory is identified by a unique number known as `address`
4. In binary notation, a byte contain value ranges from `00000000-11111111`, in decimal notation,
its value ranges from `0-255`, in hexadecimal, its value ranges from `00-FF`.
5. `Word` indicate the nominal size of pointer data.
6. The maximum size of the virtual address space can range from `0` to `2^w - 1`. `w` indicate that
the unit `word` has `w` bits.
7. Data type `char` represent a single byte, and a pointer like `char *` use the full word size of the program.
So a pointer in 32-bit program will be 4 bytes and in 64-bit program, its size will be 8 bytes.

# 3

## 3.1

讲历史，跳过

## 3.2

`-Og` 参数可以关闭优化

## 3.2.1

系统的两个重要抽象：ISA 抽象指令执行过程，让机器码执行看起来像顺序的；虚拟内存抽象机器内存，让机器内存看起来像一整条数组。

## 3.2.2

程序只是一串字节，没有任何编程时的信息。通过唯一的字节编码来确定行为，比如字节 53 代表 push 指令。反编译就是靠这种唯一字节来翻译回汇编代码。
程序在链接后和链接前地址可能不一样，因为编译器会插入执行代码和系统代码。同时会为了对齐插入占位代码。

## 3.2.3

`.` 开头的代码都是伪指令，可以忽略

## 3.3

x64 下的汇编代码都会带有一个字符后缀来指示操作数大小。b: 1byte (char); w: 2byte (short); l: 4 byte (int); q: 8byte (long)

## 3.4

* x64 上的通用寄存器每一个用处都不一样，比如 %eax 用来存 32 位的返回值: return val; 的 val 变量的值的寄存器。
%edi 用来存第一个参数，比如 void func(int i) 的 i 变量的值的寄存器。
* x64 下一个寄存器大小是 8 位，不同大小的机器操作能访问到的寄存器大小不一样。
* 1-2 字节的操作不会碰高位寄存器，但 4 字节操作会将剩余的高位 4 字节寄存器全部填 0
* 寄存器的使用有一组规范

## 3.4.1

* 指令通常有一到两个操作数，操作数有常数值，用 `$` 加整数表示。还可以是寄存器和内存。
* 最常用的操作数格式是在内存中引用常数加两个寄存器的值加一个比例因子 s，s 必须是 1,2,4 或者 8。
* 具体操作数表：P121 Fig 3-3

## 3.4.2

* `mov src dest`: copy value from src to dest
* MOV 类的指令负责把数据从源复制到目的，不对数据做任何操作，源的值都是常数，存在内存或者寄存器里，
目的值是个位置，要么是内存要么是寄存器。
* 在 x86-64 里不能将值从内存复制到内存，内存到内存的操作需要先将值暂存寄存器。
* mov 指令通常只会只会更新占用的字节位置，除了 movl，如 3.4 节所讲，32 位操作会将高位全部写 0。
* movabsq 可以直接传递 64 位值，而 movq 只能将 32 位常数作为操作数，然后再扩展到 64 位。
* movz\* 指令可以在把较小的源值复制到较大的目的的时候，把高位全设置成 0，而 movs\* 把源操作数的最高位复制填充目的的高位。

## 3.4.3

* 取指针就是引用某个寄存器
* 取值就是读取寄存器内的值

## 3.4.4

* pushq 把数据压入栈，popq 从栈顶删除数据
* 栈的生长方向是向下增长的，也就是说栈顶元素的地址值总是比栈底元素的地址值小
* 当栈指针降低到无法再降低时，就会出现 Stack Overflow 的越界错误。在 Linux 里，栈大小由系统管理。
* 栈其实就是程序内存的一块位置，和其他程序数据都是一样的，pushq 操作就是将栈指针 %esp 减 8(byte)，然后再 movq 源数据。
一个 pushq 操作等同于 `subq $8, %rsp` 加 `movq %rbp, (%rsp)`。因此 `movq 8(%rsp), %rdx` 可以把栈的第二个四字值复制到 %rdx。

> 8(%rsp) => M[$imm + R[rsp]]：从内存中读取 %rsp 的值 + 8 的地址的值，因为栈是向低位生长的，所以 -8 读前一栈帧，+8 读后一栈帧。

## 3.5

* 除了 leaq，所有的算术逻辑操作都有大小后缀

## 3.5.1

* leaq 把数据从内存读取出来并移动到寄存器，通常形式 `leaq src, dst`
* leaq 的作用不是读入数据，而是将一个有效值的地址写入目的。
* leaq 还可以计算 src 的值再写入 dst，他可以执行加法和有限的乘法操作。

## 3.5.2

* 一元操作里的操作数不仅是值，也是目的，比如 incq(%rsp) 可以让栈顶的值 + 1，类似于 C 里的 ++ 和 -- 操作。
* 二元操作里的第二个操作数即是源又是目的，第一个操作数只是一个参考值，比如 subq %rax,rdx 是计算 %rax 的值减去
%rax 的值，再写入 %rdx。类似于 C 里的 `x -= y` 的操作。

## 3.5.3

* 移位操作的第一项是移位的量，第二位是内存或者寄存器
* 移位量可以是常数，或者放在单字节的寄存器 `%cl` 上，由于指令的特殊性，只能使用这个寄存器。
* 在 x86-64 中，对 w 位长的数据移位 %cl 寄存器的低 m 位，比例是 `2^m = w`。
* 左移操作都是往右边填零，右移操作分两种， SAR 执行算术移位，在左边填满符号位，SHR 执行逻辑移位，在左边填满 0.

## 3.5.4

* 在实际编译时，编译器会优化寄存器的使用，比如变量和返回值有关联，就会不断更新 %rax 的值。

## 3.5.5

* 对 64 位的数做乘法操作将需要 128 位进行表示
* 乘积会存放在两个寄存器里，%rdx 存放高 64 位，%rax 存放低 64 位，使用两个 movq 指令来分别存放
* 做除法时，商存放在 %rax，余数存放在 %rdx，被除数应该存放在 %rax，%rdx 在无符号运算时设置为 0，在有符号运算时设置 %rax 的符号位。

## 3.6

* 机器代码通过测试数据值的结果来改变控制流或者数据流

## 3.6.1

* CPU 有一组只有一个位大小的条件码寄存器，用来存放最近一次算术计算的属性。
* `CF` 表示最近一次计算出现了进位，可以用来检查无符号计算是否溢出
* `ZF` 表示最近一次计算的结果为 0
* `SF` 表示最近一次计算得到了负数的结果
* `OF` 表示最近一个操作使得一个补码溢出了
* 除了 LEAQ 以外的算术操作都会设置条件码。
* CMP 和 TEST 指令专门用来设置条件码，但不更新寄存器
* CMP 和减法操作是一样的，但 CMP 操作只根据操作数的差来设置条件码，不更新寄存器的值
* TEST 和 AND 是一样的，也只设置条件码
* `CMPQ S1, S2` 计算的是 S2 - S1

## 3.6.2

* 条件码不是直接用来读的，通常是
   1. 根据条件码的组合来设置值 (SET 指令)
   2. 根据条件码跳转到程序的某个位置 (JUMP 指令)
   3. 有条件的传递数据
* SET 指令的尾缀不是数据大小，是条件。比如 SETL 不是设置 long word，而是当 less than 小于的时候设置值
* 在机器里表达 `a < b` 有三步
   1. 用 CMP 指令比较 a 和 b：计算 b - a 并设置条件码
   2. 用 SETL 指令设置单字节到一个寄存器的地位，比如 SETL %al
   3. 因为需要得到 32/64 位结果，所以需要把这个寄存器的其他高位给全部设置成 0，
比如 `movzbl %al, %eax` 表达将 %al 的值移动到 %eax 的低位，并把 %eax 的其余高位全部设置成 0.
* 一些指令的操作是一样的，但名字不一样，比如 `setg` (set when greater) 和 `setnle` (set when not less than) 是一模一样的。

## 3.6.3

* 直接跳转的目的地通常用一个 Label 指明，比如 `.L1`
* 间接跳转的目的地用星号加寄存器指明，比如 `jmp *%rax`，或者用寄存器的值 `jmp *(%rax)`
* jmp 是无条件跳转，其他 j 带尾缀的指令是有条件跳转，和 SET 类指令相似。

## 3.6.4

* 跳转的地址通常由编译器和链接器两者提供
* 跳转的地址通常是相对的，以跳转目标的地址，和跳转指令的下一条指令的地址的差作为编码。
也会用绝对的编码地址，由汇编器和链接器决定。
比如跳转的目标地址是 0xd，jmp 的下一条指令的地址是 0x5，那么汇编加链接之后生成的指令就是 `jmp 8`，其中 8 = int(0xd - 0x5)

## 3.6.5

* 可以用 `goto` 来理解汇编的跳转代码

## 3.6.6

* 条件转移在现代处理器上会很低效：条件满足程序沿着一条路径执行，条件不满足走另一条路径
* 更符合现代处理器性能特性的方法是：计算一个条件操作的两个结果，并根据条件选择其中的一个结果
* 因为现代处理器需要连续重叠指令，提前准备指令，分支跳转使得处理器难以准备后续的指令
* 现代处理器会有分支预测逻辑来提前猜测跳转指令，但只要猜错了，前面准备的指令就要全部丢弃，
使用条件传送而不是条件跳转可以 CPU 流水线始终是满的状态
* 条件传送 cmov\* 后缀都是条件指示，和 set 指令一样。
* 条件传送不支持单字节
* 如 `v = true ? 1 + 2 : 3 + 4`，条件传送下会把前后两个表达式都计算一遍，然后根据条件
cmov。
* 不是所有的条件表达式都用条件传送来编译，有一些非法的操作需要先判断再执行
* 对于编译器来说，选择条件跳转和条件传送的时机并不好把握，目前对于 gcc 而言，
只有表达式很简单的时候其才会优先使用条件传送。

## 3.6.7

* 汇编里没有循环指令，都是靠条件测试加上跳转来实现。
* 逆向的时候可以从 %eax 着手，找返回值和 %eax 的关系，再一次推断
* 逆向工程通用策略就是先看看寄存器如何被初始化，更新和使用的。
* while 循环有两种汇编形式
   1. 跳转到中间：先跳转到结尾的测试语句，然后再跳转回执行语句
   2. guarded-do：先做一次判断，如果满足条件，则进入 do while，否则跳转到末尾。优点是可以优化初次测试。
* for 循环会被翻译成和 while 一模一样的行为

## 3.6.8

* switch 语句使用跳转表来实现高效代码跳转执行
   - 跳转表是一个数组，内容是一个一个的代码段，用跳转值来索引这个数组并执行里面的代码段。
* 在 GCC 里用 `&&` 来创建指向代码位置的指针
* GCC 里支持的 goto 计算是扩展了 C 语言
* jmp 操作数有前缀 `*` 表明这是一个间接跳转，从某一标号为起点，间接跳转到内存的某一个位置。
* 对于重复的 Tag 就在数组里插入重复的地址，对于缺失的 Tag 就在数组里插入默认的地址
* 在汇编代码中，会使用 .rodata (Read Only Data) 存放指令地址，然后使用 `.section .rodata` 标注来加载

## 3.7

* 过程是一种封装代码的方式，接受一组参数，返回一个可选的返回值，以此实现某个功能。在大部分语言中
有 `function`, `method`, `subroutine`, `handler` 几种对过程的实现，但特性是共通的。
* 调用过程要经历下面一个或者多个机制：
   1. 传递控制：在进入一个过程之前，程序计数器要被设置成这个过程的起始地址，然后在这个过程结束之后
   要把程序计数器设置成调用方调用过程之后的下一个地址。
   2. 数据传递：调用方能够向过程提供参数，过程必须能返回一个值
   3. 分配和释放内存：过程需要为自己的局部变量分配空间，返回之前需要释放
* 栈的特性是后入先出，利用这个特性可以很轻松的实现函数调用时分配，函数调用结束后清理内存的功能。（push 和 pop）
* 要记住在 x86_64 里，栈是往低位地址生长的，越靠近栈顶的元素地址越低
* 当寄存器不够一个过程使用的时候，就会尝试在栈上分配空间，这一段属于这一个过程的栈空间叫做一个栈帧。
* 过程的返回地址通常在调用方的栈帧里。
* 如果传递的参数超过六个，寄存器里放不下，调用方可以在自己的栈帧里提前存储好。
* 如果一个过程只有六个，或者小于六个参数，那么参数都可以通过寄存器传递，而如果连局部变量
也可以存放在寄存器，且这个过程并不继续调用其他过程，那么甚至不需要给这个过程分配栈空间。

## 3.7.2

* 将控制流从调用方转向函数只需要简单的设置 PC 到函数的地址就行，但返回时的执行地址则需要记录。
* 调用函数使用 `call` 指令。调用时，`call` 指令会把 `call` 指令的下一条指令地址压入栈，然后设置 PC 到函数地址。
* 函数的执行末尾会调用 `ret` 指令，这个指令则会将 `call` 压入的地址弹出，将 PC 设置成这个地址。

假设 function A 调用 function B

```text
function A
   0x13: callq 0x3
   0x18: ...
endfunc

function B
   0x3: mov ...
   0x*: ...
   0xd: ret
endfunc
```

调用函数 B 的时候，会把 0x18，也就是下一条指令压入栈，然后把 PC (%RIP) 的值设置到 0x3，
也就是 B 函数的第一条指令地址。B 函数执行完返回的时候，ret 指令会把 0x18 从栈上弹出
然后设置到 PC 上。

* 在 x86_64 上，`call` 和 `ret` 指令都会附带 `q` 尾缀，用来指示这是 x86_64 版本，而不是 IA32。
* `call` 指令的目标数是被调用的过程的指令地址，可以是直接地址，也可以用 * 号表示这是一个间接跳转的地址。

## 3.7.3

* 大部分参数传递都是靠寄存器完成的，比如 %rdi 传递参数，%rax 返回结果
* x86_64 里最多只支持6个整数/指针的参数传递
* 参数传递使用的寄存器名字与数据大小相关，而使用的次序与参数顺序相关
* 如果有函数 A 调用函数 B，调用参数有 N > 6，那么 A 需要在 **自己** 的栈帧分配第 7 到第 N 个参数的空间，
所有参数的数据大小向 8 的倍数对齐，分配完成后再调用 callq。
* 因为先分配参数空间，再调用 callq，所以 %rsp 指向的栈顶始终是返回的地址，而 8(%rsp)，栈顶向上一个字节才是参数地址

## 3.7.4

* 必须需要局部内存空间的情况
   * 寄存器不够
   * 对一个局部变量取了地址，所以要为它生成地址
   * 变量是数组或者结构体，需要能够被引用
* 申请栈空间就是简单的将栈指针的寄存器值减少，以 8 为偏移量来访问栈。释放栈空间就是简单的增加栈指针的值。
* 存放值会做相对计算，一些能凑 8 位的小值可以放在同个栈上。

## 3.7.5

* 必须确保一个被调用方不会覆盖调用方需要使用的寄存器，所以使用寄存器是有规范的
* 按照 x86_64 的规范，%rbx,%rbp 和 %r12~%r15 被划分为被调用方保存寄存器，被调用方要么需要保存，要么就压根不去修改这些寄存器的值，
或者靠压栈和弹出恢复原来的值，以保证在调用前和调用后这些寄存器的值都是相同的。
* 除了上述的寄存器，和栈指针寄存器 %rsp，其他寄存器都是调用者保存寄存器，意味着任何的过程都能修改他们，是否保存这些寄存器的值是调用方的责任。
* 如果往栈上保存被调用方保存寄存器，恢复的时候，弹出栈的顺序要和压入时相反。

## 3.7.6

* 每个过程在调用时都会在栈里有它的私有存储空间，这就为递归调用自己提供了实现。而栈的后入先出原则也为递归提供了很方便的内存申请和释放机制。
* 对于汇编而言，递归调用自己和调用其他函数并没有什么区别
